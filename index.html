<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EmojiCut</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #2c3e50; /* Dark blue background */
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #ecf0f1;
            flex-direction: column;
            padding: 10px;
            box-sizing: border-box;
        }

        #gameCanvas {
            background-color: #34495e; /* Slightly lighter blue for canvas */
            display: block;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            touch-action: none; /* Prevent browser default touch actions */
            max-width: 95vw; /* Ensure it fits on smaller screens */
            max-height: 80vh; /* Limit height */
            border: 5px solid #2980b9; /* Border around the canvas */
        }

        #gameInfo {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            font-size: 1.5em;
            font-weight: bold;
            color: #ecf0f1;
            z-index: 10;
        }

        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            font-size: 2em;
            text-align: center;
            border-radius: 15px;
        }

        #restartButton {
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: bold;
            background: linear-gradient(145deg, #27ae60, #2ecc71); /* Green gradient */
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        #restartButton:hover {
            background: linear-gradient(145deg, #2ecc71, #27ae60);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        #restartButton:active {
            transform: translateY(1px);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        #modeSelection {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            z-index: 10;
        }

        .mode-button {
            padding: 10px 20px;
            font-size: 1.1em;
            font-weight: bold;
            background: linear-gradient(145deg, #3498db, #2980b9); /* Blue gradient */
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }

        .mode-button:hover {
            background: linear-gradient(145deg, #2980b9, #3498db);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        .mode-button.active {
            background: linear-gradient(145deg, #e67e22, #d35400); /* Orange gradient for active */
            transform: translateY(0);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #gameInfo {
                font-size: 1.2em;
                gap: 15px;
                top: 10px;
            }
            #gameOverScreen {
                font-size: 1.5em;
            }
            #restartButton {
                padding: 12px 25px;
                font-size: 1em;
            }
            .mode-button {
                padding: 8px 15px;
                font-size: 0.9em;
            }
            #modeSelection {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="modeSelection">
        <button id="classicModeBtn" class="mode-button active">Classic Mode</button>
        <button id="zenModeBtn" class="mode-button">Zen Mode</button>
    </div>
    <div id="gameInfo">
        <span id="score">Score: 0</span>
        <span id="lives">Lives: 5</span>
        <span id="difficulty" style="display: none;">Level: 1</span>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="gameOverScreen" style="display: none;">
        <h1>Game Over!</h1>
        <p>Your final score: <span id="finalScore">0</span></p>
        <button id="restartButton">Play Again</button>
    </div>

    <script>
        // Get canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Get game info elements
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const difficultyDisplay = document.getElementById('difficulty');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const classicModeBtn = document.getElementById('classicModeBtn');
        const zenModeBtn = document.getElementById('zenModeBtn');

        // Game variables
        let score = 0;
        let lives = 5;
        let gameRunning = false;
        let lastFrameTime = 0;
        let gameMode = 'classic'; // Default game mode
        let difficultyLevel = 1;
        let lastDifficultyIncreaseTime = 0;
        let lastFruitSlicedTime = 0;

        // Arrays to hold game objects
        const fruits = [];
        const slicedFruits = [];
        const sliceTrails = [];
        const explosions = [];
        const juiceEffects = [];
        const backgroundSplats = []; // NEW: Array for permanent splats
        const floatingMessages = [];
        let fruitsSlicedInCombo = new Set();
        let lastSliceEndPos = null;

        // Game settings
        const FRUIT_EMOJIS = ['üçé', 'üçè', 'üçä', 'üçã', 'üçâ', 'üçá', 'üçì', 'üçà', 'üçí', 'üçë', 'ü•≠', 'üçç', 'üçå', 'ü•ù', 'ü•ë', 'ü••'];
        const BOMB_EMOJI = 'üí£';
        const SPLAT_COLORS = {
            'üçé': '#ff6b6b', 'üçè': '#a3c9a8', 'üçä': '#ff9f43', 'üçã': '#feca57',
            'üçâ': '#e84118', 'üçá': '#54a0ff', 'üçì': '#ff6b81', 'üçà': '#badc58',
            'üçí': '#eb4d4b', 'üçë': '#ffaf40', 'ü•≠': '#ee5a24', 'üçç': '#f7b731',
            'üçå': '#f9d342', 'ü•ù': '#575fcf', 'ü•ë': '#2d3436', 'ü••': '#bdc3c7'
        };
        const JUICY_FRUITS = ['üçâ', 'üçä', 'üçì'];
        const GRAVITY = 0.3;
        const FRUIT_SIZE = 60;
        let FRUIT_SPAWN_INTERVAL = 1000;
        let MAX_FRUITS_ON_SCREEN = 5;
        const SLICE_TRAIL_LENGTH = 10;
        const SLICE_TRAIL_FADE_TIME = 200;
        const SLICED_FRUIT_FADE_DURATION = 600;
        const EXPLOSION_DURATION = 500;
        const JUICE_FADE_DURATION = 800;
        const SPLAT_FADE_DURATION = 5000;
        const MESSAGE_FADE_DURATION = 1500;
        const COMBO_TIMEOUT = 1000;

        // Mouse/Touch tracking variables
        let isSlicing = false;
        let sliceStart = { x: 0, y: 0 };
        let sliceEnd = { x: 0, y: 0 };
        let currentSlicePath = [];

        // Adjust canvas size to fit window
        function resizeCanvas() {
            canvas.width = window.innerWidth * 0.9;
            canvas.height = window.innerHeight * 0.7;
            if (canvas.width < 300) canvas.width = 300;
            if (canvas.height < 400) canvas.height = 400;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Fruit Class
        class Fruit {
            constructor(x, y, emoji, isBomb = false) {
                this.x = x;
                this.y = y;
                this.radius = FRUIT_SIZE / 2;
                this.emoji = emoji;
                this.vy = -Math.random() * 2 - 15;
                this.vx = (Math.random() - 0.5) * 1.5;
                this.isBomb = isBomb;
                this.sliced = false;
                this.hitboxRadius = this.isBomb ? this.radius * 0.8 : this.radius * 1.2;
            }

            update(deltaTime) {
                this.x += this.vx * deltaTime / 16;
                this.y += this.vy * deltaTime / 16;
                this.vy += GRAVITY * deltaTime / 16;

                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx *= -0.8;
                } else if (this.x + this.radius > canvas.width) {
                    this.x = canvas.width - this.radius;
                    this.vx *= -0.8;
                }
            }

            draw() {
                ctx.font = `${FRUIT_SIZE}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x, this.y);
            }

            contains(px, py) {
                const distSq = (px - this.x) * (px - this.x) + (py - this.y) * (py - this.y);
                return distSq < this.hitboxRadius * this.hitboxRadius;
            }
        }

        // Sliced Fruit Class
        class SlicedFruit {
            constructor(fruit, sliceAngle) {
                this.emoji = fruit.emoji;
                this.radius = FRUIT_SIZE / 2;
                this.isBomb = fruit.isBomb;
                this.sliceAngle = sliceAngle;

                const impulseStrength = 5;
                const perpendicularAngle = this.sliceAngle + Math.PI / 2;

                this.leftHalf = {
                    x: fruit.x,
                    y: fruit.y,
                    vx: fruit.vx + impulseStrength * Math.cos(perpendicularAngle + Math.PI),
                    vy: fruit.vy + impulseStrength * Math.sin(perpendicularAngle + Math.PI),
                    rotation: Math.random() * Math.PI * 2,
                    angularVelocity: (Math.random() - 0.5) * 0.4
                };

                this.rightHalf = {
                    x: fruit.x,
                    y: fruit.y,
                    vx: fruit.vx + impulseStrength * Math.cos(perpendicularAngle),
                    vy: fruit.vy + impulseStrength * Math.sin(perpendicularAngle),
                    rotation: Math.random() * Math.PI * 2,
                    angularVelocity: (Math.random() - 0.5) * 0.4
                };
                this.creationTime = performance.now();
            }

            update(deltaTime) {
                this.leftHalf.x += this.leftHalf.vx * deltaTime / 16;
                this.leftHalf.y += this.leftHalf.vy * deltaTime / 16;
                this.leftHalf.vy += GRAVITY * deltaTime / 16;
                this.leftHalf.rotation += this.leftHalf.angularVelocity * deltaTime / 16;

                this.rightHalf.x += this.rightHalf.vx * deltaTime / 16;
                this.rightHalf.y += this.rightHalf.vy * deltaTime / 16;
                this.rightHalf.vy += GRAVITY * deltaTime / 16;
                this.rightHalf.rotation += this.rightHalf.angularVelocity * deltaTime / 16;
            }

            draw(currentTime) {
                const age = currentTime - this.creationTime;
                let alpha = 1 - (age / SLICED_FRUIT_FADE_DURATION);
                if (alpha < 0) alpha = 0;
                ctx.globalAlpha = alpha;

                ctx.save();
                ctx.translate(this.leftHalf.x, this.leftHalf.y);
                ctx.rotate(this.leftHalf.rotation);
                ctx.rotate(-this.sliceAngle);
                ctx.beginPath();
                const clipBuffer = 2;
                ctx.rect(-this.radius - clipBuffer, -this.radius - clipBuffer, this.radius + clipBuffer, FRUIT_SIZE + 2 * clipBuffer);
                ctx.clip();
                ctx.font = `${FRUIT_SIZE}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, 0);
                ctx.restore();

                ctx.save();
                ctx.translate(this.rightHalf.x, this.rightHalf.y);
                ctx.rotate(this.rightHalf.rotation);
                ctx.rotate(-this.sliceAngle);
                ctx.beginPath();
                ctx.rect(0, -this.radius - clipBuffer, this.radius + clipBuffer, FRUIT_SIZE + 2 * clipBuffer);
                ctx.clip();
                ctx.font = `${FRUIT_SIZE}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, 0);
                ctx.restore();

                ctx.globalAlpha = 1;
            }
        }

        class JuiceParticle {
            constructor(x, y, vx, vy, radius, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.radius = radius;
                this.color = color;
                this.creationTime = performance.now();
            }

            update(deltaTime) {
                this.x += this.vx * deltaTime / 16;
                this.y += this.vy * deltaTime / 16;
                this.vy += GRAVITY * deltaTime / 16;
            }

            draw(currentTime) {
                const age = currentTime - this.creationTime;
                let alpha = 1 - (age / JUICE_FADE_DURATION);
                if (alpha < 0) alpha = 0;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        class JuiceEffect {
            constructor(fruitEmoji, slicePoint, comboSize) {
                this.creationTime = performance.now();
                this.particles = [];
                const color = SPLAT_COLORS[fruitEmoji] || '#ffffff';
                const baseParticles = 20;
                const particleFactor = JUICY_FRUITS.includes(fruitEmoji) ? 2 : 1;
                const numParticles = (baseParticles * particleFactor) + comboSize * 5;

                for (let i = 0; i < numParticles; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 5 + 3;
                    const radius = Math.random() * 3 + 2;
                    this.particles.push(new JuiceParticle(
                        slicePoint.x, slicePoint.y,
                        speed * Math.cos(angle),
                        speed * Math.sin(angle),
                        radius,
                        color
                    ));
                }
            }

            update(deltaTime) {
                this.particles.forEach(p => p.update(deltaTime));
            }

            draw(currentTime) {
                this.particles.forEach(p => p.draw(currentTime));
            }

            isFinished() {
                return performance.now() - this.creationTime > JUICE_FADE_DURATION;
            }
        }
        
        // UPDATED: BackgroundSplat class to draw a "boba" style splat
        class BackgroundSplat {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * 20 + 40;
                this.rotation = Math.random() * Math.PI * 2;
                this.path = this.createRandomCentralBlob();
                this.satellites = this.createSatelliteSplats();
            }

            createRandomCentralBlob() {
                const points = [];
                const numPoints = Math.floor(Math.random() * 6) + 8;
                const baseRadius = this.size / 2;
                const jitter = baseRadius * 0.4;
                for (let i = 0; i < numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 2;
                    const radius = baseRadius + (Math.random() - 0.5) * jitter;
                    points.push({
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius
                    });
                }
                return points;
            }
            
            createSatelliteSplats() {
                const satellites = [];
                const numSatellites = Math.floor(Math.random() * 5) + 3; // 3 to 7 satellites
                const maxDistance = this.size * 1.5;
                for(let i = 0; i < numSatellites; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * maxDistance + this.size / 2;
                    const size = Math.random() * 5 + 3;
                    satellites.push({
                        x: Math.cos(angle) * distance,
                        y: Math.sin(angle) * distance,
                        size: size
                    });
                }
                return satellites;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Draw central blob
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.moveTo(this.path[0].x, this.path[0].y);
                for(let i = 1; i < this.path.length; i++) {
                    ctx.lineTo(this.path[i].x, this.path[i].y);
                }
                ctx.closePath();
                ctx.fill();
                
                // Draw satellites
                this.satellites.forEach(satellite => {
                    ctx.beginPath();
                    ctx.arc(satellite.x, satellite.y, satellite.size, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.restore();
                ctx.globalAlpha = 1;
            }
        }
        
        // Explosion, FloatingMessage and other classes are the same as before...
        class ExplosionParticle {
            constructor(x, y, emoji, initialVx, initialVy) {
                this.x = x;
                this.y = y;
                this.emoji = emoji;
                this.vx = initialVx;
                this.vy = initialVy;
                this.creationTime = performance.now();
                if (this.emoji === 'üí•') {
                    this.size = FRUIT_SIZE * 3;
                } else {
                    this.size = FRUIT_SIZE * 0.7;
                }
            }

            update(deltaTime) {
                this.x += this.vx * deltaTime / 16;
                this.y += this.vy * deltaTime / 16;
                this.vy += GRAVITY * deltaTime / 16;
            }

            draw(currentTime) {
                const age = currentTime - this.creationTime;
                let alpha = 1 - (age / EXPLOSION_DURATION);
                if (alpha < 0) alpha = 0;
                ctx.globalAlpha = alpha;

                ctx.font = `${this.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x, this.y);
                ctx.globalAlpha = 1;
            }
        }

        class ExplosionEffect {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.particles = [];
                this.creationTime = performance.now();
                this.particles.push(new ExplosionParticle(x, y, 'üí•', 0, 0));
                const numClouds = 5 + Math.floor(Math.random() * 3);
                for (let i = 0; i < numClouds; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 5;
                    this.particles.push(new ExplosionParticle(
                        x, y, 'üí®',
                        speed * Math.cos(angle),
                        speed * Math.sin(angle)
                    ));
                }
            }

            update(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    this.particles[i].update(deltaTime);
                    const age = performance.now() - this.particles[i].creationTime;
                    if (age > EXPLOSION_DURATION) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            draw(currentTime) {
                this.particles.forEach(p => p.draw(currentTime));
            }

            isFinished() {
                return this.particles.length === 0;
            }
        }
        
        class FloatingMessage {
            constructor(x, y, text) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.vy = -1;
                this.creationTime = performance.now();
            }

            update(deltaTime) {
                this.y += this.vy * deltaTime / 16;
            }

            draw(currentTime) {
                const age = currentTime - this.creationTime;
                let alpha = 1 - (age / MESSAGE_FADE_DURATION);
                if (alpha < 0) alpha = 0;
                ctx.globalAlpha = alpha;

                ctx.font = `bold 24px 'Inter'`;
                ctx.fillStyle = 'yellow';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1;
            }
        }

        function spawnFruit() {
            if (fruits.length >= MAX_FRUITS_ON_SCREEN) return;
            const x = Math.random() * (canvas.width - FRUIT_SIZE * 2) + FRUIT_SIZE;
            const y = canvas.height + FRUIT_SIZE / 2;
            let isBomb = false;
            if (gameMode === 'classic') {
                isBomb = Math.random() < 0.15;
            }
            const emoji = isBomb ? BOMB_EMOJI : FRUIT_EMOJIS[Math.floor(Math.random() * FRUIT_EMOJIS.length)];
            fruits.push(new Fruit(x, y, emoji, isBomb));
        }

        function processCombo(x, y) {
            if (fruitsSlicedInCombo.size > 1) {
                const comboSize = fruitsSlicedInCombo.size;
                const bonusPoints = comboSize * 10 * (comboSize - 1);
                score += bonusPoints;
                scoreDisplay.textContent = `Score: ${score}`;
                floatingMessages.push(new FloatingMessage(x, y, `COMBO x${comboSize} (+${bonusPoints})`));
            }
            fruitsSlicedInCombo.clear();
        }

        let lastSpawnTime = 0;
        function updateGame(currentTime) {
            if (!gameRunning) return;
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw permanent background splats first
            backgroundSplats.forEach(splat => splat.draw());

            if (fruitsSlicedInCombo.size > 0 && currentTime - lastFruitSlicedTime > COMBO_TIMEOUT) {
                const x = lastSliceEndPos ? lastSliceEndPos.x : canvas.width / 2;
                const y = lastSliceEndPos ? lastSliceEndPos.y : canvas.height / 2;
                processCombo(x, y);
            }

            if (gameMode === 'classic' && currentTime - lastDifficultyIncreaseTime > 30000) {
                difficultyLevel++;
                difficultyDisplay.textContent = `Level: ${difficultyLevel}`;
                FRUIT_SPAWN_INTERVAL = Math.max(200, FRUIT_SPAWN_INTERVAL - 50);
                MAX_FRUITS_ON_SCREEN = Math.min(15, MAX_FRUITS_ON_SCREEN + 1);
                lastDifficultyIncreaseTime = currentTime;
            }

            if (currentTime - lastSpawnTime > FRUIT_SPAWN_INTERVAL) {
                const numToSpawn = Math.min(3, Math.floor(Math.random() * difficultyLevel) + 1);
                for (let i = 0; i < numToSpawn; i++) {
                     spawnFruit();
                }
                lastSpawnTime = currentTime;
            }

            for (let i = fruits.length - 1; i >= 0; i--) {
                const fruit = fruits[i];
                fruit.update(deltaTime);
                fruit.draw();
                if (gameMode === 'classic' && fruit.y > canvas.height + FRUIT_SIZE && !fruit.sliced) {
                    if (!fruit.isBomb) {
                        lives--;
                        livesDisplay.textContent = `Lives: ${lives}`;
                    }
                    fruits.splice(i, 1);
                    if (lives <= 0) {
                        endGame();
                        return;
                    }
                } else if (gameMode === 'zen' && fruit.y > canvas.height + FRUIT_SIZE && !fruit.sliced) {
                    fruits.splice(i, 1);
                }
            }

            for (let i = slicedFruits.length - 1; i >= 0; i--) {
                const slicedFruit = slicedFruits[i];
                slicedFruit.update(deltaTime);
                slicedFruit.draw(currentTime);
                const age = currentTime - slicedFruit.creationTime;
                if ((slicedFruit.leftHalf.y > canvas.height + FRUIT_SIZE && slicedFruit.rightHalf.y > canvas.height + FRUIT_SIZE) || age > SLICED_FRUIT_FADE_DURATION) {
                    slicedFruits.splice(i, 1);
                }
            }

            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                explosion.update(deltaTime);
                explosion.draw(currentTime);
                if (explosion.isFinished()) {
                    explosions.splice(i, 1);
                }
            }

            for (let i = juiceEffects.length - 1; i >= 0; i--) {
                const juiceEffect = juiceEffects[i];
                juiceEffect.update(deltaTime);
                juiceEffect.draw(currentTime);
                if (juiceEffect.isFinished()) {
                    juiceEffects.splice(i, 1);
                }
            }
            
            for (let i = floatingMessages.length - 1; i >= 0; i--) {
                const message = floatingMessages[i];
                message.update(deltaTime);
                message.draw(currentTime);
                const age = currentTime - message.creationTime;
                if (age > MESSAGE_FADE_DURATION) {
                    floatingMessages.splice(i, 1);
                }
            }

            for (let i = sliceTrails.length - 1; i >= 0; i--) {
                const trail = sliceTrails[i];
                const age = currentTime - trail.timestamp;
                if (age > SLICE_TRAIL_FADE_TIME) {
                    sliceTrails.splice(i, 1);
                } else {
                    ctx.save();
                    ctx.strokeStyle = `rgba(255, 255, 255, ${1 - (age / SLICE_TRAIL_FADE_TIME)})`;
                    ctx.lineWidth = 5;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(trail.path[0].x, trail.path[0].y);
                    for (let j = 1; j < trail.path.length; j++) {
                        ctx.lineTo(trail.path[j].x, trail.path[j].y);
                    }
                    ctx.stroke();
                    ctx.restore();
                }
            }

            requestAnimationFrame(updateGame);
        }

        function handleSlice(currentX, currentY) {
            if (!isSlicing) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const adjustedX = (currentX - rect.left) * scaleX;
            const adjustedY = (currentY - rect.top) * scaleY;
            
            const newPoint = { x: adjustedX, y: adjustedY };
            lastSliceEndPos = newPoint;

            currentSlicePath.push(newPoint);
            if (currentSlicePath.length > SLICE_TRAIL_LENGTH) {
                currentSlicePath.shift();
            }

            sliceTrails.push({ path: [...currentSlicePath], timestamp: performance.now() });

            for (let i = fruits.length - 1; i >= 0; i--) {
                const fruit = fruits[i];
                if (!fruit.sliced) {
                    let entryPointIndex = -1;
                    let exitPointIndex = -1;
                    for (let j = 0; j < currentSlicePath.length; j++) {
                        const point = currentSlicePath[j];
                        if (fruit.contains(point.x, point.y)) {
                            if (entryPointIndex === -1) {
                                entryPointIndex = j;
                            }
                            exitPointIndex = j;
                        }
                    }

                    if (entryPointIndex !== -1) {
                        fruit.sliced = true;
                        if (fruit.isBomb) {
                            lives--;
                            livesDisplay.textContent = `Lives: ${lives}`;
                            explosions.push(new ExplosionEffect(fruit.x, fruit.y));
                            processCombo(fruit.x, fruit.y);
                            if (lives <= 0) {
                                endGame();
                                return;
                            }
                        } else {
                            score++;
                            scoreDisplay.textContent = `Score: ${score}`;
                            const sliceAngle = Math.atan2(currentSlicePath[exitPointIndex].y - currentSlicePath[entryPointIndex].y, currentSlicePath[entryPointIndex].x - currentSlicePath[entryPointIndex].x);
                            
                            const comboSize = fruitsSlicedInCombo.size;
                            fruitsSlicedInCombo.add(fruit);
                            lastFruitSlicedTime = performance.now();
                            
                            // JUICE AND SPLAT CREATION LOGIC
                            const entryPoint = currentSlicePath[entryPointIndex];
                            const exitPoint = currentSlicePath[exitPointIndex];
                            if (entryPoint && exitPoint) {
                                juiceEffects.push(new JuiceEffect(fruit.emoji, entryPoint, comboSize));
                                const randomX = fruit.x + (Math.random() - 0.5) * 40;
                                const randomY = fruit.y + (Math.random() - 0.5) * 40;
                                backgroundSplats.push(new BackgroundSplat(randomX, randomY, SPLAT_COLORS[fruit.emoji]));
                            }
                            
                            slicedFruits.push(new SlicedFruit(fruit, sliceAngle));
                        }
                        fruits.splice(i, 1);
                    }
                }
            }
        }

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            isSlicing = true;
            fruitsSlicedInCombo.clear();
            sliceStart = { x: e.clientX, y: e.clientY };
            currentSlicePath = [];
            handleSlice(sliceStart.x, sliceStart.y);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isSlicing) {
                sliceEnd = { x: e.clientX, y: e.clientY };
                handleSlice(sliceEnd.x, sliceEnd.y);
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            isSlicing = false;
            currentSlicePath = [];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const adjustedX = (e.clientX - rect.left) * scaleX;
            const adjustedY = (e.clientY - rect.top) * scaleY;
            processCombo(adjustedX, adjustedY);
        });

        canvas.addEventListener('mouseleave', () => {
            isSlicing = false;
            currentSlicePath = [];
            const x = lastSliceEndPos ? lastSliceEndPos.x : canvas.width / 2;
            const y = lastSliceEndPos ? lastSliceEndPos.y : canvas.height / 2;
            processCombo(x, y);
        });

        // Touch events for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isSlicing = true;
            fruitsSlicedInCombo.clear();
            sliceStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            currentSlicePath = [];
            handleSlice(sliceStart.x, sliceStart.y);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isSlicing) {
                sliceEnd = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                handleSlice(sliceEnd.x, sliceEnd.y);
            }
        });

        canvas.addEventListener('touchend', (e) => {
            isSlicing = false;
            currentSlicePath = [];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const adjustedX = (e.changedTouches[0].clientX - rect.left) * scaleX;
            const adjustedY = (e.changedTouches[0].clientY - rect.top) * scaleY;
            processCombo(adjustedX, adjustedY);
        });

        canvas.addEventListener('touchcancel', () => {
            isSlicing = false;
            currentSlicePath = [];
            const x = lastSliceEndPos ? lastSliceEndPos.x : canvas.width / 2;
            const y = lastSliceEndPos ? lastSliceEndPos.y : canvas.height / 2;
            processCombo(x, y);
        });

        // Game state functions
        function startGame() {
            score = 0;
            lives = 5;
            difficultyLevel = 1;
            FRUIT_SPAWN_INTERVAL = 1000;
            MAX_FRUITS_ON_SCREEN = 5;
            fruits.length = 0;
            slicedFruits.length = 0;
            sliceTrails.length = 0;
            explosions.length = 0;
            juiceEffects.length = 0;
            backgroundSplats.length = 0; // NEW: Clear the background splats
            floatingMessages.length = 0;
            fruitsSlicedInCombo.clear();
            lastSliceEndPos = null;
            scoreDisplay.textContent = `Score: ${score}`;
            livesDisplay.textContent = `Lives: ${lives}`;
            difficultyDisplay.textContent = `Level: ${difficultyLevel}`;
            gameOverScreen.style.display = 'none';
            gameRunning = true;
            lastFrameTime = performance.now();
            lastSpawnTime = performance.now();
            lastDifficultyIncreaseTime = performance.now();
            lastFruitSlicedTime = performance.now();

            if (gameMode === 'zen') {
                livesDisplay.style.display = 'none';
                difficultyDisplay.style.display = 'none';
            } else {
                livesDisplay.style.display = 'inline-block';
                difficultyDisplay.style.display = 'inline-block';
            }

            requestAnimationFrame(updateGame);
        }

        function endGame() {
            gameRunning = false;
            finalScoreDisplay.textContent = score;
            gameOverScreen.style.display = 'flex';
        }

        restartButton.addEventListener('click', startGame);

        classicModeBtn.addEventListener('click', () => {
            gameMode = 'classic';
            classicModeBtn.classList.add('active');
            zenModeBtn.classList.remove('active');
            livesDisplay.style.display = 'inline-block';
            difficultyDisplay.style.display = 'inline-block';
            if (!gameRunning) {
                lives = 5;
                livesDisplay.textContent = `Lives: ${lives}`;
            }
        });

        zenModeBtn.addEventListener('click', () => {
            gameMode = 'zen';
            zenModeBtn.classList.add('active');
            classicModeBtn.classList.remove('active');
            livesDisplay.style.display = 'none';
            difficultyDisplay.style.display = 'none';
            if (!gameRunning) {
                lives = 5;
                livesDisplay.textContent = `Lives: ${lives}`;
            }
        });

        window.onload = startGame;
    </script>
</body>
</html>
